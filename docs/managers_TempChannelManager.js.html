<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: managers/TempChannelManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: managers/TempChannelManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const EventEmitter = require('node:events');

/**
 * @typedef {Object} TempChannelData
 * @property {import('discord.js').VoiceChannel} channel The voice channel
 * @property {import('discord.js').GuildMember} owner The if of the creator of the channel
 */

/**
 * @typedef {Object} TempChannelManagerData
 * @property {import('discord.js').Snowflake} channelId The id of the temp create voice channel
 * @property {TempChannelManagerRegisterOptions} options The options of the temp create voice channel
 * @property {Array&lt;TempChannelData>} tempChannels An array of all temp channels the temp create channel manages
 */

/**
 * @typedef {Object} TempChannelManagerRegisterOptions
 * @property {import('discord.js').Snowflake} categoryId The id of the category the channel should get created to
 * @property {?Boolean} autoDeleteIfEmpty If the channel should be deleted automatically if the channel is empty (Default: true)
 * @property {?Boolean} autoDeleteIfOwnerLeaves If the channel should be deleted automatically if the owner leaves the channel (Default: true)
 * @property {?Number} bitrate The bitrate for the channel (Default: 64000)
 * @property {Function} channelName The name of the channel (Params: member and count)
 * @property {Number} maxUsers The amount of users that can join the channel
 */

/**
 * The temp channel manager for creating and managing temporary voice channels
 */
class TempChannelManager extends EventEmitter {

    /**
     * The constructor
     * @param {import('discord.js').Client} client
     */
    constructor(client) {

        super();

        /**
         * The discord client
         * @type {import('discord.js').Client}
         */
        this.client = client;

        /**
         * A map of all temp voice channels
         * @type {Array&lt;TempChannelManagerData>}
         * @private
         */
        this._channels = new Array();

        this.client.on('channelDelete', (channel) => this._handleChannelDelete(channel));
        this.client.on('voiceStateUpdate', (oldState, newState) => this._handleVoiceStateUpdate(oldState, newState));

    }

    /**
     * Handles a channel delete
     * @param {import('discord.js').DMChannel|import('discord.js').GuildChannel} channel 
     * @private
     */
    async _handleChannelDelete(channel) {

        const tempCreateChannel = this._channels.find((channelData) => channelData.channelId === channel.id);

        if(tempCreateChannel) {

            this._channels = this._channels.filter((channelData) => channelData.channelId !== channel.id);

            return this.emit('channelUnregistered', tempCreateChannel);

        }

        const tempCreateChannelTempChannels = this._channels.find((channelData) => channelData.tempChannels.some((channel) => channel.channel.id === channel.id));

        if(tempCreateChannelTempChannels) {

            tempCreateChannel.tempChannels = tempCreateChannel.tempChannels.filter((channel) => channel.channel.id !== channel.id);

        }

    }

    /**
     * Handles a voice state update
     * @param {import('discord.js').VoiceState} oldState 
     * @param {import('discord.js').VoiceState} newState 
     * @private
     */
    async _handleVoiceStateUpdate(oldState, newState) {

        const isDisconnected = !!oldState.channelId &amp;&amp; !newState.channelId;
        const isJoined = !oldState.channelId &amp;&amp; !!newState.channelId;
        const isMoved = !!oldState.channelId &amp;&amp; !!newState.channelId &amp;&amp; oldState.channelId !== newState.channelId;

        if(isDisconnected || isMoved) {

            const tempCreateChannel = this._channels.find((channelData) => channelData.tempChannels.some((channel) => channel.channel.id === oldState.channelId))

            if(tempCreateChannel) {

                const tempCreateChannelTempChannelToDelete = tempCreateChannel.tempChannels.find((channel) => channel.channel.id === oldState.channelId);

                if((tempCreateChannel.options.autoDeleteIfEmpty &amp;&amp; oldState.channel.members.size === 0) || (tempCreateChannel.options.autoDeleteIfOwnerLeaves &amp;&amp; !oldState.channel.members.has(tempCreateChannelTempChannelToDelete.owner.id))) {

                    tempCreateChannelTempChannelToDelete.channel
                        .delete()
                        .then(() => {

                            tempCreateChannel.tempChannels = tempCreateChannel.tempChannels.filter((channel) => channel.channel.id !== tempCreateChannelTempChannelToDelete.channel.id);

                            this.emit('temoVoiceChannelDeleted', newState.member, tempCreateChannelTempChannelToDelete.channel, this.client.channels.resolve(tempCreateChannel.channelId));

                        })
                        .catch((err) => {

                            this.emit('error', err), 'Unable to delete channel: ' + tempCreateChannelTempChannelToDelete.channel.id;

                        });

                }

            }

        }

        if(isJoined || isMoved) {

            const tempCreateChannel = this._channels.find((channelData) => channelData.channelId === newState.channelId);

            if(!tempCreateChannel) return;

            const tempChannelCount = tempCreateChannel.tempChannels.length + 1;
            const tempChannelName = tempCreateChannel.options.channelName(newState.member, tempChannelCount);

            const tempChannel = await newState.guild.channels.create(tempChannelName, { bitrate: tempCreateChannel.options.bitrate, parent: tempCreateChannel.options.categoryId, type: 'GUILD_VOICE', userLimit: tempCreateChannel.options.maxUsers });

            this.emit('tempVoiceChannelCreated', newState.member, tempChannel, this.client.channels.resolve(tempCreateChannel.channelId));

            newState.setChannel(tempChannel);

            tempCreateChannel.tempChannels.push({ channel: tempChannel, owner: newState.member });

        }

    }

    /**
     * Registers a channel
     * @param {import('discord.js').Snowflake} channelId The id of the temp create channel
     * @param {TempChannelManagerRegisterOptions} options The options for the temp create channel
     * @returns {Boolean}
     */
    register(channelId, options = { categoryId: null, autoDeleteIfEmpty: true, autoDeleteIfOwnerLeaves: true, bitrate: 64000, channelName: (count, member) => `#${count} | ${member}'s Lounge`, maxUsers: 0 }) {

        const channelData = {

            channelId,
            options,
            tempChannels: []

        };

        this._channels.push(channelData);
        this.emit('channelRegistered', channelData);

        return true;

    }

    /**
     * Unregisters a channel
     * @param {import('discord.js').Snowflake} channelId The id of the temp create channel
     * @returns {Boolean|null}
     */
    unregister(channelId) {

        const channel = this._channels.find((channel) => channel.channelId === channelId);

        if(!channel) return null;

        this._channels = this._channels.filter((channel) => channel.channelId !== channelId);
        this.emit('channelUnregeistered', channel);

        return true;

    }

}

module.exports = TempChannelManager;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BackUp.html">BackUp</a></li><li><a href="Badges.html">Badges</a></li><li><a href="Base.html">Base</a></li><li><a href="BaseCommand.html">BaseCommand</a></li><li><a href="BaseInteraction.html">BaseInteraction</a></li><li><a href="ButtonInteraction.html">ButtonInteraction</a></li><li><a href="ButtonInteractionManager.html">ButtonInteractionManager</a></li><li><a href="Colors.html">Colors</a></li><li><a href="Command.html">Command</a></li><li><a href="CommandManager.html">CommandManager</a></li><li><a href="Emojis.html">Emojis</a></li><li><a href="Event.html">Event</a></li><li><a href="EventManager.html">EventManager</a></li><li><a href="InteractionManager.html">InteractionManager</a></li><li><a href="Logger.html">Logger</a></li><li><a href="MenuInteraction.html">MenuInteraction</a></li><li><a href="MenuInteractionManager.html">MenuInteractionManager</a></li><li><a href="MessageInteraction.html">MessageInteraction</a></li><li><a href="MessageInteractionManager.html">MessageInteractionManager</a></li><li><a href="ModalInteraction.html">ModalInteraction</a></li><li><a href="ModalInteractionManager.html">ModalInteractionManager</a></li><li><a href="Partner.html">Partner</a></li><li><a href="Route.html">Route</a></li><li><a href="SlashCommand.html">SlashCommand</a></li><li><a href="SlashCommandManager.html">SlashCommandManager</a></li><li><a href="TempChannelManager.html">TempChannelManager</a></li><li><a href="TranslationManager.html">TranslationManager</a></li><li><a href="UserInteraction.html">UserInteraction</a></li><li><a href="UserInteractionManager.html">UserInteractionManager</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Thu Mar 24 2022 21:55:51 GMT+0100 (Mitteleurop√§ische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
