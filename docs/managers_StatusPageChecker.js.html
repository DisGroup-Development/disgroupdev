<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: managers/StatusPageChecker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: managers/StatusPageChecker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Collection, MessageEmbed, Snowflake, WebhookClient } = require('discord.js');
const { DateTime } = require('luxon');
const EventEmitter = require('node:events');
const FileSystem = require('node:fs');
const Fetch = import('node-fetch');

const { DisGroupDevError, Messages } = require('../errors/DisGroupDevError');

let loadedIncidents = false;

/**
 * @typedef {Object} IncidentData
 * @property {String} id The id of the incident
 * @property {String} lastUpdate The last update of the incident
 * @property {Snowflake} messageId The id of the message of the incident
 * @property {Boolean} resolved If the incident is resolved
 */

/**
 * @typedef {Object} IncidentDataRaw
 * @property {IncidentDataRawComponents[]} components The components of the incident
 * @property {String} created_at The creation date of the incident
 * @property {String} id The id of the incident
 * @property {String} impact The impact of the incident
 * @property {IncidentDataRawComponent[]} incident_updates The updates of the incident
 * @property {String} monitoring_at The monitoring date of the incident
 * @property {String} name The name of the incident
 * @property {String} page_id The id of the status page
 * @property {String} resolved_at The resolved date of the incident
 * @property {String} shortlink The link of the incident
 * @property {String} started_at The start date of the incident
 * @property {String} status The status of the incident
 * @property {String} updated_at The last update of the incident
 */

/**
 * @typedef {Object} IncidentDataRawComponent
 * @property {String} created_at The creation date of the component
 * @property {String} description The description of the component
 * @property {Boolean} group If the component is a group
 * @property {String|null} group_id The id of the group of the component
 * @property {String} id The id of the component
 * @property {String} name The name of the component
 * @property {Boolean} only_show_if_degraded If the component is only shown if degraded
 * @property {String} page_id The id of the status page
 * @property {Number} position The position of the component
 * @property {Boolean} showcase If the component is in the showcase
 * @property {String|null} start_date The start date of the component
 * @property {String} status The status of the component
 * @property {String} updated_at The last update of the component
 */

/**
 * @typedef {Object} IncidentDataRawComponentUpdate
 * @property {String} code The code of the component update
 * @property {String} name The name of the component update
 * @property {String} new_status The new status of the component update
 * @property {String} old_status The old status of the component update
 */

/**
 * @typedef {Object} IncidentDataRawUpdate
 * @property {IncidentDataRawComponentUpdate[]} affected_components The affected components of the update
 * @property {String} body The body of the update
 * @property {String} created_at The creation date of the update
 * @property {String|null} custom_tweet The custom tweet of the update
 * @property {Boolean} deliver_notifications If the update should be delivered to the users
 * @property {String} display_at The display date of the update
 * @property {String} id The id of the incident update
 * @property {String} incident_id The id of the incident
 * @property {String} status The status of the incident update
 * @property {String|null} tweet_id The id of the tweet of the update
 * @property {String} update_at The date of the incident update
 */

/**
 * @typedef {Object} StatusPageCheckerOptions
 * @property {StatusPageCheckerOptionsColors} colors The colors of the embeds
 * @property {String} storage The json file to save the incidents to
 * @property {String} url The URL of the status page you want to monitore
 * @property {WebhookClient} webhook webhook client
 */

/**
 * @typedef {Object} StatusPageCheckerOptionsColors
 * @property {String} BLACK (default: #000000)
 * @property {String} GREEN (default: #51f34d)
 * @property {String} ORANGE (default: #fcb22d)
 * @property {String} RED (default: #fe6b61)
 * @property {String} YELLOW (default: #ffde22)
 */

/**
 * The status page checker.
 * Inspired by @almostSouji
 * @extends {EventEmitter}
 * @class
 */
class StatusPageChecker extends EventEmitter.EventEmitter {

    /**
     * The constructor of the status page checker class.
     * @param {StatusPageCheckerOptions} options
     */
    constructor(options = { colors: { BLACK: '#000000', GREEN: '#51f34d', ORANGE: '#fcb22d', RED: '#fe6b61', YELLOW: '#ffde22' } }) {

        super();

        /**
         * The cache with all page incidents
         * @type {Collection&lt;String, IncidentData>}
         * @public
         */
        this.incidents = new Collection();

        /**
         * The options of the status page checker.
         * @type {StatusPageCheckerOptions}
         * @public
         */
        this.options = options;

        if(!options?.storage || typeof options.storage !== 'string') throw new DisGroupDevError(Messages.INVALID_LOCATION);
        if(!options?.url || typeof options.url !== 'string') throw new DisGroupDevError(Messages.INVALID_URL);
        if(!options?.webhook || !options.webhook instanceof WebhookClient) throw new DisGroupDevError(Messages.NOT_INSTANCE_OF(options?.webhook, WebhookClient));

        /**
         * The webhook client.
         * @type {WebhookClient}
         * @public
         */
        this.webhook = options.webhook;

        this.check();

        setInterval(() => this.check(), 60_000);

    }

    /**
     * Fetches the status page
     * @returns {Promise&lt;Fetch.Response>}
     * @private
     */
    async _fetch() {

        const data = await (await Fetch).default(`${this.options.url}/api/v2/incidents.json`).then((r => r.json()));

        return data;

    }

    /**
     * Generates an incident embed
     * @param {IncidentDataRaw} incident
     * @returns {Promise&lt;MessageEmbed>}
     * @private
     */
    _generateEmbed(incident) {

        return new Promise(async (resolve, reject) => {

            try {

                const embedColor =
                    incident.status === 'resolved' || incident.status === 'postmortem'
                        ? this.options.colors.GREEN : incident.impact === 'critical'
                            ? this.options.colors.RED : incident.impact === 'major'
                                ? this.options.colors.ORANGE : incident.impact === 'minor'
                                    ? this.options.colors.YELLOW : this.options.colors.BLACK;

                const affectedComponentsNames = incident.components.map((c) => c.name);

                const embed = new MessageEmbed()
                    .setTitle(incident.name)
                    .setColor(embedColor)
                    .setFooter({ text: `ID: ${incident.id}` })
                    .setTimestamp(new Date(incident.started_at))
                    .setURL(incident.shortlink)

                for(const incidentUpdate of incident.incident_updates.reverse()) {

                    const incidentUpdateDate = DateTime.fromISO(incidentUpdate.created_at);
                    const incidentUpdateDateTimeStamp = `&lt;t:${Math.floor(incidentUpdateDate.toSeconds())}:R>`;

                    embed.addField(`${incidentUpdate.status.charAt(0).toUpperCase()}${incidentUpdate.status.slice(1)} (${incidentUpdateDateTimeStamp})`, incidentUpdate.body);

                }

                const embedDescriptionParts = [`・ Impact: ${incident.impact}`];

                if(affectedComponentsNames.length) embedDescriptionParts.push(`・ Affected components: ${affectedComponentsNames.join(', ')}`);

                embed.setDescription(embedDescriptionParts.join('\n'));

                resolve(embed);

            } catch(e) {

                reject(new DisGroupDevError(e));

            }

        });

    }

    /**
     * Loads all incidents from the storage file
     * @returns {Promise&lt;Boolean|DisGroupDevError>}
     * @private
     */
    _loadIncidents() {

        return new Promise(async (resolve, reject) => {

            try {

                const rawData = await this._loadRawIncidents();

                await rawData.forEach(rawDataIncident => {

                    this.incidents.set(rawDataIncident.id, {
                        id: rawDataIncident.id,
                        lastUpdate: rawDataIncident.lastUpdate,
                        messageId: rawDataIncident.messageId,
                        resolved: rawDataIncident.resolved
                    });

                });

                loadedIncidents = true;

                resolve(true);

            } catch(e) {

                reject(new DisGroupDevError(e));

            }

        });

    }

    /**
     * Loads all incidents raw from the storage file
     * @returns {Promise&lt;Array&lt;IncidentData>>}
     * @private
     */
    _loadRawIncidents() {

        return new Promise(async (resolve, reject) => {

            const storage = await require('util').promisify(FileSystem.exists)(this.options.storage);

            if(!storage) {

                await require('util').promisify(FileSystem.writeFile)(this.options.storage, JSON.stringify(new Array()), 'utf-8');

                resolve([]);

            } else {

                const storageContent = await require('util').promisify(FileSystem.readFile)(this.options.storage);

                try {

                    const storageIncidents = await JSON.parse(storageContent.toString());

                    if(Array.isArray(storageIncidents)) {

                        resolve(storageIncidents)

                    } else {

                        resolve([]);

                    }

                } catch (e) {

                    resolve([]);

                }

            }

        });

    }

    /**
     * Saves the incidents to the file
     * @returns {Promise&lt;Boolean>}
     * @private
     */
    async _save() {

        await require('util').promisify(FileSystem.writeFile)(this.options.storage, JSON.stringify(this.incidents, null, 4), 'utf-8');

        return true;

    }

    /**
     * The check function
     * @returns {Promise&lt;Boolean|DisGroupDevError>}
     */
    async check() {

        if(!loadedIncidents) {

            await this._loadIncidents();

            return this.check();

        }

        /**
         * Emitted when a check has started.
         * @event StatusPageChecker#heartbeat
         */
        this.emit('heartbeat');

        try {

            const fetched = await this._fetch();
            /** @type {IncidentDataRaw[]} */
            const fetchedIncidents = fetched.incidents;

            for(const incident of fetchedIncidents?.reverse()) {

                const incidentData = this.incidents.get(incident.id);

                if(!incidentData) {

                    /**
                     * Emitted when a new incident has been found
                     * @event StatusPageChecker#incidentCreate
                     * @param {IncidentData} incident
                     */
                    this.emit('incidentCreate', incidentData);

                    return this.updateIncident(incident);

                }

                const incidentUpdate = DateTime.fromISO(incident.updated_at ?? incident.created_at);

                if(DateTime.fromISO(incidentData.lastUpdate) &lt; incidentUpdate) {

                    /**
                     * Emitted when an incident has been updated
                     * @event StatusPageChecker#incidentUpdate
                     * @param {IncidentData} incident
                     */
                    this.emit('incidentUpdate', incidentData);

                    return this.updateIncident(incident, incidentData.messageId);

                }

            }

        } catch (e) {

            throw new DisGroupDevError(e);

        }

    }

    /**
     * Updates an incident
     * @param {IncidentDataRaw} incident The raw data of the incident
     * @param {?String} messageId The id of the webhook message
     * @returns {Promise&lt;Boolean|DisGroupDevError>}
     */
    updateIncident(incident, messageId = null) {

        return new Promise(async (resolve, reject) => {

            const embed = await this._generateEmbed(incident);

            try {

                const webhookMessage = await ((messageId &amp;&amp; typeof messageId === 'string') ? this.webhook.editMessage(messageId, { embeds: [embed] }) : this.webhook.send({ embeds: [embed] }));

                this.incidents.set(incident.id, {

                    id: incident.id,
                    lastUpdate: DateTime.now().toISO(),
                    messageId: webhookMessage.id,
                    resolved: incident.status === 'resolved' || incident.status === 'postmortem'

                });

                await this._save();

                resolve(true);

            } catch(e) {

                reject(new DisGroupDevError(e))

            }

        });

    }

}

module.exports = StatusPageChecker;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Badges.html">Badges</a></li><li><a href="BaseComponent.html">BaseComponent</a></li><li><a href="BaseInteraction.html">BaseInteraction</a></li><li><a href="Colors.html">Colors</a></li><li><a href="ContextInteraction.html">ContextInteraction</a></li><li><a href="ContextInteractionManager.html">ContextInteractionManager</a></li><li><a href="DisGroupDevError.html">DisGroupDevError</a></li><li><a href="Emojis.html">Emojis</a></li><li><a href="Event.html">Event</a></li><li><a href="EventManager.html">EventManager</a></li><li><a href="InteractionManager.html">InteractionManager</a></li><li><a href="Logger.html">Logger</a></li><li><a href="Partner.html">Partner</a></li><li><a href="SlashCommand.html">SlashCommand</a></li><li><a href="SlashCommandInteractionManager.html">SlashCommandInteractionManager</a></li><li><a href="StatusPageChecker.html">StatusPageChecker</a></li><li><a href="TranslationManager.html">TranslationManager</a></li><li><a href="Utilities.html">Utilities</a></li></ul><h3>Events</h3><ul><li><a href="EventManager.html#event:eventLoad">eventLoad</a></li><li><a href="EventManager.html#event:eventReload">eventReload</a></li><li><a href="EventManager.html#event:eventUnload">eventUnload</a></li><li><a href="InteractionManager.html#event:slashCommandDeploy">slashCommandDeploy</a></li><li><a href="InteractionManager.html#event:slashCommandLoad">slashCommandLoad</a></li><li><a href="InteractionManager.html#event:slashCommandReload">slashCommandReload</a></li><li><a href="InteractionManager.html#event:slashCommandUnload">slashCommandUnload</a></li><li><a href="StatusPageChecker.html#event:heartbeat">heartbeat</a></li><li><a href="StatusPageChecker.html#event:incidentCreate">incidentCreate</a></li><li><a href="StatusPageChecker.html#event:incidentUpdate">incidentUpdate</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Fri May 27 2022 17:37:59 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
